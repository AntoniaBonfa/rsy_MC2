---
title: "Content based movie recommender Antonia"
output:
  html_document:
    highlight: tango
    df_print: paged
    table-of-contents: yes
    toc: yes
    toc_depth: 4
    toc_float: yes
    code_folding: hide
  pdf_document:
    toc: yes
    toc_depth: '4'
---

```{r include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)
```


###Bibliotheken
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(gridExtra)
library(dplyr)
library(data.table)
library(ggplot2)
library(reshape2)
library(rsample)
library(recommenderlab)
```


7.1 Erzeugung von Film- & Nutzerprofilen [20 Punkte]
Für die Film- und Nutzerprofile verwenden wir den MovieLense Datensatz von Recommenderlab. 
Für die Nutzer:innen haben wir eine Matrix mit allen gerateten Filmen. Um Empfehlungen zu machen, wandeln wir die Ratings um; für alle Ratings die grösser als 3 sind setzen wir eine 1 (= der Film hat gefallen). Idealerweise sollten wir natürlich statt einem fixen Masstab für alle Nutzer:innen lieber die Werte normieren, sprich jeden Wert um das durchschnittliche Rating des Nutzers korrigieren und dann die positiven Werte als Likes nehmen. So würden wir auch das individuelle Rating-Verhalten der Nutzer:innen berücksichtigen. 
```{r 1. MovieLense Daten einlesen}
data(MovieLense)
df_user_ratings <- as.data.frame(as(MovieLense, "matrix"))

```

```{r 2. Binäre User-Liked-Items Matrix für alle Nutzer erzeugen}
df_binary <- ifelse(df_user_ratings >3 ,1,0)

```


```{r 3. Dimension der User-Liked-Items Matrix prüfen und ausgeben}
print(dim(df_binary))
```
Die Matrix enthält `r toString(dim(df_binary)[1])` User und `r toString(dim(df_binary)[2])` Items. 


Bei den Filmen  haben wir bereits eine Matrix mit den Filmen und deren Genres die wir verwenden können. Ich forme die Matrix minim um, damit die Filme als Reihennamen verfügbar sind und entferne unnötige Spalten wie Erscheinungsjahr und Link zum Eintrag. 
```{r 4. Movie-Genre Matrix für alle Filme erzeugen}
df_movie_genre <- as.data.frame(MovieLenseMeta)
rownames(df_movie_genre) <- df_movie_genre$title
df_movie_genre <- df_movie_genre %>% select(-c("year", "url", "title"))

m_movie_genre <- as(df_movie_genre, "matrix")

```


```{r 5. Dimension der Movie-Genre Matrix prüfen und ausgeben}
dim(m_movie_genre)

```
Die Matrix enthält `r toString(dim(df_movie_genre)[1])` Filme und `r toString(dim(df_movie_genre)[2]-1)` Genres  

Als nächstes schauen wir uns für jeden Film an, zu welchen Genres er gehört und erstellen so ein ganz individuelles Filmprofil. 

```{r 6. Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren}
#ChatGPT genutzt um die Genre-Kombinationen zu erhalten. Prompt: "I am working with the MovieLense dataframe and I need to modify the MovieLenseMeta dataframe to have an additional column with the combination of genres. So if a movie has "Action" and "Adventure" as their genres, the column should have "Action-Adventure" as value. can you help me write this code?" Resultat davon ist der Code für die Spalte "movie_profiles". Im Original wollte ChatGPT für die Genres einen Vektor schreiben mit den expliziten Genre-Namen und die Funktion nur auf diese Spalten anwenden. Da das aber ohnehin alle Spalten sind war das ein unnötiger Mehraufwand.


df_movie_genre$movie_profile <- apply(df_movie_genre, 1, function(row) {
  paste(names(row)[row == 1], collapse = '-')
})

df_genres_count <-  as.data.frame(table(df_movie_genre$movie_profile, dnn = "genre"))

n_single_genres <- df_genres_count %>% filter(Freq == 1) %>% count()

df_top30 <-df_genres_count %>%  slice_max(n = 30, order_by = Freq) 
df_rest <- df_genres_count %>%  
  filter(!(genre %in% df_top30$genre)) %>% 
  summarise("Freq" = sum(Freq)) %>% 
  mutate(genre = "Others combined")

ggplot()+
  geom_col(data = df_top30, aes(Freq, genre))+
  geom_col(data = df_rest, aes(Freq, genre), fill = "red")+
  labs(y = "",
       x = "Anzahl Filme",
       title = "Verteilung der Filme nach Genre-Kombination",
       subtitle = paste0("(Top-30 Kombinationen, von insgesamt ", toString(dim(df_genres_count)[1]), ")"))


```
Insgesamt haben wir `r toString(dim(df_genres_count)[1])` unterschiedliche Genre-Kombinationen, wobei `r toString(n_single_genres[1,1])` eine einzigartige Kombi sind die nur jeweils 1 Film hat. 

Wir sehen, dass Drama das häufigste Genre ist, gefolgt von Comedy. Comedy ist allgemein eine beliebte Kombination; gleich 5 der Top 30 Kombinationen enthalten Comedy (6 wenn man Comedy selber mitzählt). Beliebter ist nur noch Action, mit insgesamt 6 resp. 7 Kombinationen in den Top 30. Wenn wir noch zum Vergleich die Häufigkeit für die nicht kombinierten Genres anschauen (nächster Plot) sehen wir, dass sich die Kombinationen dort spiegeln: auch hier ist Drama, gefolgt von Comedy das häufigste Genre. 

```{r Grafik Genres allg}

df_genres_count2 <- rownames_to_column(as.data.frame(colSums(df_movie_genre[2:19])))
colnames(df_genres_count2) <- c("genre", "count")
ggplot(df_genres_count2, aes(count, genre))+
  geom_col()+
  labs(title= "Verteilung Filmgenres",
       x = "Anzahl Filme",
       y = "Genre")
```
Als nächstes schauen wir uns an, welche Genres die Nutzer:innen gerne schauen. Dazu verwenden wir den Datensatz mit den User-liked-movies und multiplizieren diesen mit der Film-Genre Matrix. 

```{r 7. Nutzerprofile im Genre-Vektorraum erzeugen}
#Zur Erzeugung der Nutzerprofile im Genre-Vektorraum wird empfohlen folgendermassen vorzugehen: 
#User-Genre-Profil Matrix durch Multiplikation von User-Liked-Items Matrix und Movie-Genre Matrix erzeugen.


#movie - Filmprofil Matrix
movie_profiles <- rownames_to_column(df_movie_genre, "movie") %>% 
  select(movie, movie_profile) %>% 
  mutate(value = 1) %>%
  pivot_wider(id_cols = movie,names_from = movie_profile, values_from = value, values_fill = 0) %>% 
  column_to_rownames(var = "movie")

#Dataframes in Matrizen umwandeln
m_movie_profiles <- as(movie_profiles, "matrix")
m_user_liked <- as(df_binary, "matrix")
m_user_liked[is.na(m_user_liked)] <- 0


  
#Matrixmultiplikation 
m_user_genre <- m_user_liked %*% m_movie_genre

dim(m_movie_genre)
head(m_user_genre)
```
Wenn wir wieder ein Histogram machen mit den Anzahl Likes pro Genre ist das Bild sehr ähnlich wie die Verteilung bei den Filmen. 
```{r}
df_user_genres_count <- rownames_to_column(as.data.frame(colSums(m_user_genre)))
colnames(df_user_genres_count) <- c("genre", "count")
ggplot(df_user_genres_count, aes(count, genre))+
  geom_col()+
  labs(title= "Verteilung Genres Userbewertungen",
       x = "Anzahl Filme",
       y = "Genre")


## Grafik mit Movie Profilen statt nur Genres
m_user_movie_profile <- m_user_liked %*% m_movie_profiles

df_user_mprofile_count <- rownames_to_column(as.data.frame(colSums(m_user_movie_profile)))
colnames(df_user_mprofile_count) <- c("genre", "count")
df_user_mprofile_count %>% slice_max(order_by = count, n = 30) %>% 
ggplot(aes(count, genre))+
  geom_col()+
  labs(title= "Verteilung Genre-Kombis Userbewertungen",
       subtitle = "Top 30 Genre-Kombis gem. User",
       x = "Anzahl Filme",
       y = "Genre")


```


```{r 8. Dimension der User-Genre-Profil Matrix prüfen und ausgeben}
dim(m_user_genre)
```
Nach der Matrixmultiplikation haben wir weiterhin `r toString(dim(m_user_genre)[1])` User  und `r toString(dim(m_user_genre)[2])` Genre-Profile. Die Multiplikation scheint also korrekt verlaufen zu sein.   

##STILL TO DO
```{r 9. Anzahl unterschiedlicher Nutzerprofile bestimmen mit Stärke der Genre-Kombination}
#(a) vollständig
rownames_to_column(as.data.frame(m_user_genre), "user") %>% 
  pivot_longer(!user, names_to = "movie", values_to = "value") %>% 
  filter(value > 0) %>% 
  distinct(movie)


#(b) binär 
#Zur Analyse der Anzahl unterschiedlicher Nutzer-Profile, Fall (b) kann z.B. mutate(across(.cols = everything(), .fns = ~ ifelse(.x > 0, 1, 0))) verwendet werde
df_binary[is.na(df_binary)] <- 0
m_user_genre2 <- as(df_binary, "matrix") %*% m_movie_profiles 

rownames_to_column(as.data.frame(m_user_genre2), "user") %>% 
  pivot_longer(!user, names_to = "movie", values_to = "value") %>% 
  filter(value > 0) %>% 
  distinct(movie)





m3 <- as.data.frame(m_user_genre) %>% mutate(across(.cols = everything(), .fns = ~ ifelse(.x > 0, 1, 0)))


rownames_to_column(as.data.frame(m3), "user") %>% 
  pivot_longer(!user, names_to = "movie", values_to = "value") %>% 
  filter(value > 0) %>% 
  distinct(movie)



dim(distinct(m3))
sum(unique(m3))
dim(m3)

```


### 7.2 Ähnlichkeit von Nutzern und Filmen [10 Punkte]
Als nächstes wollen wir die Cosine-Ähnlichkeit zwischen Filmen und Nutzer:innen bestimmen. Dazu verwenden wir wieder nur die reinen Genres und nicht die Kombinationen. 
```{r 1. Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen}
# Funktion zur Berechnung von Cosinus-Ähnlichkeiten zweier Matrizen namens calc_cos_similarity_twomtrx() implementieren, um Nutzerprofile und Filme im Vektorraum der Genres zu vergleichen. Die richtige Funktionsweise soll an einem einfachen Beispiel getestet und dokumentiert werden.
calc_cos_similarity_twomx <- function(m1, m2){
  #### Parameter: 2 Matrizen für die die Cosine-Ähnlichkeit bestummen werden soll####
  #### Output: Matrix mit den Cosine-Similarities ####
  numerator <- (m1 %*% t(m2))
  denominator <- sqrt(rowSums(m1^2) %*% t(rowSums(m2^2)))
  cos_sim <- numerator / denominator
  return(cos_sim)
  } 
```


### Testen der Funktion anhand eines einfachen Beispiels
Zur Überprüfung meiner Funktion habe ich ein sehr einfaches Beispiel gemacht welches zu funktionieren scheint; die Cosine-Similarity der beiden Matrizen sieht gut aus:
```{r Test Funktion}
m1 <- matrix(1:4, nrow = 2, ncol = 2)
m2 <- matrix(1:4, nrow = 2, ncol = 2)

print("Matrix 1:")
m1
print("Matrix 2:")
m2

print("Cosine-Ähnlichkeit der beiden Matrizen:")
calc_cos_similarity_twomx(m1,m2)

```

Mithilfe der Funktion berechnen wir nun die Cosine-Similarity zwischen der Film-Genre Matrix und der User-Genre Matrix. 
```{r 2. Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben.}

#m_csim_user_movie_orig <- calc_cos_similarity_twomx(m_user_genre, m_movie_profiles)

m_csim_user_movie <- calc_cos_similarity_twomx(m_user_genre, m_movie_genre)

dim(m_movie_genre)


dim(m_csim_user_movie)
quantile(m_csim_user_movie, na.rm = TRUE)

```
```{r 3. 5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen uns ausgeben}
#Bei der Berechnung der 5-Zahlen Statistik der Cosinus-Ähnlichkeiten von Nutzern und Filmen sind explizit auch NAs und Mittelwert auszugeben.

stat5point <- function(df){
  stat5point <- as.data.frame(t(quantile(df,na.rm = TRUE))) %>% 
  mutate(mean = mean(df, na.rm=TRUE), 
         NAs = sum(is.na(df)))
  colnames(stat5point) <- c("Min", "25%", "Median", "75%", "Max", "Mean", "NAs")
  return(stat5point)
}

stat5point(m_csim_user_movie)


```
Wenn wir uns die Kennzahlen anschauen sehen wir, dass wir recht plausible Daten haben; der Durchschnitt der Ähnlichkeit ist bei 40%, die maximale Ähnlichkeit 97%. 
Wir haben 1664 NAs, was wohl dem Genre "unknown" geschuldet ist, welches keinerlei Bewertungen hatte. 

Wenn wir den Dichteplot anschauen, sehen wir, dass es eine Häufung der Ähnlichkeiten zwischen 0.25 und 0.6 gibt, wobei wir auch sehr viele Werte haben die 0 sind (keinerlei Ähnlichkeit). Wie zu erwarten nimmt die Dichte der Ähnlichkeiten ab je höher sie wird - wir haben also wenige User, deren Genre-Geschmack sehr ähnlich ist zu den vorhanden Film-Genre-Profilen. 

```{r 4. Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.}


df_csim_long <- rownames_to_column(as.data.frame(m_csim_user_movie), "user") %>% 
  pivot_longer(!user, names_to = "movie", values_to = "value")

ggplot(df_csim_long, aes(value))+
  geom_density()+
  labs(title = "Dichteplot von Cosinus-Ähnlichkeit",
       x = "Cosinus-Ähnlichkeit",
       y = "Dichte")

```

```{r 5. Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”,“640” und “710” visualisieren.}
userlist <- c(241, 414, 477, 526, 640, 710)

df_csim_long %>% filter(user %in% userlist) %>% 
  ggplot(aes(value, color = user))+
  geom_density()

```


### 7.3 Empfehlbare Filme [6 Punkte]
1. Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
Wir setzen alle nicht gerateten Filme auf 1 und alles, was eine Bewertung hat auf 0 - so wissen wir, welche Filme die Nutzer nicht geschaut haben. Die Sumem der 1er muss der Summe der NAs im ursprünglichen Datensatz entsprechen: 
```{r}
#Zum Maskieren bewerteter Filme (s. “Negativabzug”) wird empfohlen folgendermassen vorzugehen:
#“Negativabzug” der User-Liked-Items Matrix konstruieren, indem Ratings aller bewerteten Filme auf 0 gesetzt werden, die restlichen auf 1
df_neg <- df_user_ratings %>% 
  modify(~ ifelse(is.na(.), 1, 0))

#prüfen, ob Anzahl NAs im ursprünglichen Dataframe der Anzahl 1er entspricht im Negativabzug (sollte 0 ergeben)
sum(is.na(df_user_ratings)) - sum(df_neg == 1)


```
Da der Wert 0 ist sollte es stimmen. 

2. Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
users_neg <- c(5,25,50,150)
df_neg_rowsum <- as.data.frame(rowSums(df_neg[users_neg,])) %>%
  `colnames<-`("Anzahl") %>% 
  rownames_to_column("User") %>% 
  arrange(Anzahl)

print(df_neg_rowsum)

ggplot((df_neg_rowsum), aes(User, Anzahl, fill = User))+
  geom_col()+
  labs(title = "Anzahl Zeilen in Negativmatrix")

```

3. 5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
##TO DO: Fix Stats Function!!
```{r}

stat5point(df_neg[users_neg,])

```

### 7.4 Top-N Empfehlungen [12 Punkte]
1. Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
```{r}
dim(df_neg)
dim(m_csim_user_movie)

m_neg_csim <- as(df_neg, "matrix") * m_csim_user_movie
 

```


2. Dimension der Matrix für die Bewertung aller Filme prüfen.
```{r}
dim(m_neg_csim)



```

3. Top-20 Listen extrahieren und Länge der Listen pro Nutzer prüfen.
```{r}
#Bei Ausgabe der Top-20 Empfehlungen pro Nutzer wird empfohlen folgendermassen vorzugehen
#Funktion get_topn_recos() implementieren, mit welcher sich pro User aus allen unbewerteten Filmen auf Basis der Ähnlichkeit von Nutzern und Filmen die Top-N Empfehlungen für beliebige N extrahieren lassen.
#Zur Prüfung der Länge der Top-20 Listen pro Nutzer ist die 5-Zahlen Statistik der Anzahl Empfehlungen pro Nutzer auszugegeben.
get_topn_recos <- function(df,N=20){
  df_topN <- rownames_to_column(as.data.frame(df), "user") %>% 
    pivot_longer(!user, names_to = "movie", values_to = "value") %>% 
    arrange(user,desc(value)) %>% 
    mutate(rank = rep(1:ncol(df), nrow(df))) %>% 
    filter(rank <= N)

  return(df_topN)
}

df_top20 <- get_topn_recos(m_neg_csim, 50)
#get_topn_recos(m_neg_csim)$stats
```



4. Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50, 100 für alle Nutzer visuell vergleichen.
```{r Minimale Ähnlichkeitsscores }
analyze_topn_recos <- function(df, Ns){
  ##### Parameter: df: Datensatz mit Cosine-Ähnlichkeitm Ns: Liste von N für TopN Empfehlungen  ##### 
  ##### Output: Histogram der minimalen Ähnlichkeitsscores   ##### 
  
  ##### Datensatz erstellen mit den TopN Empfehlungen pro User ##### 
  min_scores <- data.frame()
  for (n in Ns){
    recs <- get_topn_recos(df, n)
    recs <- recs %>% 
      group_by(user) %>% 
      summarize(min_score = min(value),
                N = n)
    min_scores <- rbind(min_scores, recs)}
  
  min_scores <- min_scores %>% arrange(user, N)

  ##### Plot erstellen   ##### 
  plot <- ggplot(min_scores, aes(min_score))+
    geom_histogram(bins = 100)+
    facet_wrap(~paste0("Top", N))+
    labs(title = "Verteilung der minimalen Scores in den Toplisten",
         x = "Cosine-Ähnlichkeit",
         y = "Anzahl")
    
  return(list(min_scores, plot))

}

Ns <- c(10, 20, 50, 100)
analyze_topn_recos(m_neg_csim, Ns)
```
Im Histogram sehen wir dass bei zunehmendem N auch mehr tiefe Scores dabei sind. Dies können wir auch statistisch überprüfen mit den Quantilen:
```{r Quantile der Verteilungen}


```


5. Top-20 Empfehlungen für Nutzer “5”, “25”, “50”, “150” visualisieren.
```{r Clevelandplot Funktion}

create_cleveland_plot <- function(usermatrix = m_user_genre, moviematrix = df_movie_genre, cosim_matrix = m_neg_csim, users, Ns){
  #### Dokumentation ####
  #Kreiert einen Clevelandplot für beliebige Anzahl User und Ns
  
  ##### Parameter #####
  #usermatrix: Matrix mit Nutzern & Genres
  #moviematrix: Matrix mit Filmen und Genres
  #cosim Matrix: Matrix mit der Cosine-Similarity
  #users: liste von Nutzern
  #Ns: Liste von Ns für TopN-Empfehlungen
  
  ##### Output: Plot-Objekt, welches nachher weiterverarbeitet werden kann (z.B. mit Facet-Wrap) #####

  
  #### Empfehlungen erstellen & mit Genres ergänzen  #### 
  df_recos <- data.frame()
  for(N in Ns){
    df_topN <- get_topn_recos(m_neg_csim, N)
    df_topN['N'] <- N
    df_recos <- rbind(df_recos, df_topN)
  }
  df_topN_movies <- rownames_to_column(moviematrix, "movie") %>% filter(movie %in% df_recos$movie)
  df_topN_genre <- merge(df_recos, df_topN_movies, by="movie")

  ####   Empfehlungen umformen für Plot  #### 
  df_topN_genres_cleveland <- df_topN_genre %>% 
    arrange(user, rank) %>% 
    filter(user %in% users) %>% 
  select(-c(movie, value, rank, movie_profile)) %>% 
    pivot_longer(!c(user, N), names_to = "genre", values_to = "n") %>% 
  group_by(user, N, genre) %>% 
  summarize(n = sum(n)) %>% 
  ungroup %>% 
  mutate(tot = sum(n),
         pct = n / tot,
         source = "Empfehlungen", 
         N = N)  %>% 
  select(!tot) 
  
df_user_genre_cleveland <- data.frame()

  #### Nutzerprofile umformen für Plot   #### 
  for(N in Ns){
  df_user_N <- rownames_to_column(as.data.frame((m_user_genre)), "user")  %>%
    filter(user %in% users) %>% 
    pivot_longer(!user, names_to = "genre", values_to = "n") %>% 
    mutate(tot = sum(n),
         pct = n / tot,
         source = "Nutzerprofil",
         N = N)  %>% 
    select(!c(tot)) 
  df_user_genre_cleveland <- rbind(df_user_genre_cleveland, df_user_N)
  }
  
  #### Datensätze kombinieren & Plot erstellen   #### 
  clp <- rbind(df_user_genre_cleveland, df_topN_genres_cleveland) %>% 
  ggplot(aes(x = pct, genre, color = source))+
  geom_point(alpha = 0.5) +
  geom_line(aes(group = genre), color = "black") +
  labs(title = paste("Genre-Profil für ausgewählte Nutzer:innen"),
       x = "Prozentualer Anteil", 
       y = "Genre",
       color = "Art") +
    scale_x_continuous(limits = c(0,0.5))


  return(clp)

}

```


```{r Clevelandplot für Nutzer, fig.height=10}
create_cleveland_plot(users = users_neg, Ns = c(20))+facet_wrap(~paste("User", user))+labs(subtitle = "Anzahl Empfehlungen: 20")


```

6. Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r Cleveland für Nutzer 133 und 555,  fig.align="center", echo = FALSE, fig.height=10}
Nlist <- c(20,30,40,50)
userlist <- c(133,555)
create_cleveland_plot(users = userlist, Ns = Nlist)+
  facet_grid(paste0("Top", N)~paste("User", user))

```
